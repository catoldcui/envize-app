# envizeApp Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a lightweight Tauri + React desktop app for managing envize environment variable profiles.

**Architecture:** Single-screen app with sidebar (profile list + toggles), main panel (profile editor), and bottom status bar. Frontend shells out to `envize` CLI via Tauri commands. Profile file content is read/written directly via Tauri fs API.

**Tech Stack:** Tauri v2, React 19, TypeScript, Tailwind CSS v4, Vite, Vitest + React Testing Library

---

### Task 0: Install Rust toolchain

Tauri v2 requires Rust. Install it before scaffolding.

**Step 1: Install Rust**

Run: `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y`

**Step 2: Verify**

Run: `source "$HOME/.cargo/env" && rustc --version && cargo --version`
Expected: version strings for both

**Step 3: Commit** — nothing to commit, system-level install

---

### Task 1: Scaffold Tauri + React project

**Files:**
- Create: `package.json`, `vite.config.ts`, `tsconfig.json`, `tsconfig.node.json`, `index.html`, `src/main.tsx`, `src/App.tsx`, `src/index.css`
- Create: `src-tauri/` (generated by Tauri CLI)
- Create: `tailwind.config.js` (if needed by Tailwind v4, otherwise CSS-only)

**Step 1: Scaffold with create-tauri-app**

Run from parent directory of envizeApp (the repo already exists, so we scaffold in a temp dir and move files):

```bash
cd /Users/chenhuicui/code/envizeApp
npm create tauri-app@latest . -- --template react-ts --manager npm --yes
```

If it refuses to write into a non-empty dir, scaffold to a temp dir and move:

```bash
cd /tmp && npm create tauri-app@latest envizeApp-tmp -- --template react-ts --manager npm --yes
cp -r /tmp/envizeApp-tmp/* /tmp/envizeApp-tmp/.* /Users/chenhuicui/code/envizeApp/ 2>/dev/null
rm -rf /tmp/envizeApp-tmp
```

**Step 2: Install dependencies**

Run: `cd /Users/chenhuicui/code/envizeApp && npm install`

**Step 3: Add Tailwind CSS**

Run: `npm install -D tailwindcss @tailwindcss/vite`

Update `vite.config.ts` to add the Tailwind plugin:

```ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
  plugins: [react(), tailwindcss()],
  clearScreen: false,
  server: {
    port: 1420,
    strictPort: true,
    watch: { ignored: ["**/src-tauri/**"] },
  },
});
```

Replace `src/index.css` with:

```css
@import "tailwindcss";
```

**Step 4: Add testing dependencies**

Run: `npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom`

Add to `vite.config.ts` (or create `vitest.config.ts`):

```ts
/// <reference types="vitest/config" />
```

And add `test` block:

```ts
test: {
  environment: "jsdom",
  globals: true,
  setupFiles: ["./src/test-setup.ts"],
}
```

Create `src/test-setup.ts`:

```ts
import "@testing-library/jest-dom/vitest";
```

Update `tsconfig.json` `compilerOptions` to include:

```json
"types": ["vitest/globals"]
```

**Step 5: Add npm scripts**

Ensure `package.json` scripts include:

```json
{
  "dev": "vite",
  "build": "tsc && vite build",
  "preview": "vite preview",
  "test": "vitest run",
  "test:watch": "vitest",
  "tauri": "tauri"
}
```

**Step 6: Verify frontend builds and tests run**

Run: `npm run build`
Expected: successful build

Run: `npm test`
Expected: no tests found (or passes if scaffold includes one)

**Step 7: Add Tauri shell plugin**

The app needs to execute CLI commands. Add the Tauri shell plugin:

Run: `cd src-tauri && cargo add tauri-plugin-shell`

Update `src-tauri/src/main.rs` (or `lib.rs`) to register the plugin:

```rust
fn main() {
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

Add shell plugin permissions in `src-tauri/capabilities/default.json`:

```json
{
  "permissions": [
    "core:default",
    "shell:allow-execute",
    "shell:allow-open",
    "fs:allow-read",
    "fs:allow-write"
  ]
}
```

Also configure the allowed shell commands in `src-tauri/capabilities/default.json` or `tauri.conf.json` to allow running `envize`.

**Step 8: Verify Tauri builds**

Run: `npm run tauri build -- --debug`
Expected: Compiles (may take a few minutes first time)

**Step 9: Clean up scaffold boilerplate**

Remove any default scaffold content from `src/App.tsx`. Replace with:

```tsx
function App() {
  return <div className="h-screen flex flex-col">envizeApp</div>;
}
export default App;
```

**Step 10: Commit**

```bash
git add -A
git commit -m "scaffold Tauri + React + Tailwind + Vitest project"
```

---

### Task 2: Profile parser (`src/lib/parser.ts`)

Parses and serializes the envize dotenv profile format with metadata headers.

**Real profile format** (from `~/.envize/profiles/claude.env`):

```bash
# @description: Claude API configuration using {{CLAUDE_MODEL}}
# @tags: ai, anthropic, llm

ANTHROPIC_API_KEY=test1
CLAUDE_MODEL=2
```

Note: metadata uses `# @key: value` format (with colon).

**Files:**
- Create: `src/lib/parser.ts`
- Create: `src/lib/parser.test.ts`

**Step 1: Write failing tests**

Create `src/lib/parser.test.ts`:

```ts
import { describe, it, expect } from "vitest";
import { parseProfile, serializeProfile, type Profile } from "./parser";

const SAMPLE = `# @description: My API keys for development
# @tags: ai, api

API_KEY=sk-abc123
API_URL=https://api.example.com
`;

describe("parseProfile", () => {
  it("parses metadata and variables", () => {
    const result = parseProfile(SAMPLE);
    expect(result.description).toBe("My API keys for development");
    expect(result.tags).toEqual(["ai", "api"]);
    expect(result.variables).toEqual([
      { key: "API_KEY", value: "sk-abc123" },
      { key: "API_URL", value: "https://api.example.com" },
    ]);
  });

  it("handles profile with no metadata", () => {
    const result = parseProfile("FOO=bar\nBAZ=qux\n");
    expect(result.description).toBe("");
    expect(result.tags).toEqual([]);
    expect(result.variables).toEqual([
      { key: "FOO", value: "bar" },
      { key: "BAZ", value: "qux" },
    ]);
  });

  it("handles empty profile", () => {
    const result = parseProfile("");
    expect(result.description).toBe("");
    expect(result.tags).toEqual([]);
    expect(result.variables).toEqual([]);
  });

  it("ignores plain comments", () => {
    const result = parseProfile("# just a comment\nFOO=bar\n");
    expect(result.variables).toEqual([{ key: "FOO", value: "bar" }]);
  });

  it("handles values with equals signs", () => {
    const result = parseProfile("URL=https://example.com?a=1&b=2\n");
    expect(result.variables).toEqual([
      { key: "URL", value: "https://example.com?a=1&b=2" },
    ]);
  });
});

describe("serializeProfile", () => {
  it("round-trips a profile", () => {
    const profile: Profile = {
      description: "My API keys",
      tags: ["ai", "api"],
      variables: [
        { key: "API_KEY", value: "sk-abc123" },
        { key: "API_URL", value: "https://api.example.com" },
      ],
    };
    const serialized = serializeProfile(profile);
    expect(serialized).toBe(
      `# @description: My API keys\n# @tags: ai, api\n\nAPI_KEY=sk-abc123\nAPI_URL=https://api.example.com\n`
    );
  });

  it("omits empty metadata", () => {
    const profile: Profile = {
      description: "",
      tags: [],
      variables: [{ key: "FOO", value: "bar" }],
    };
    expect(serializeProfile(profile)).toBe("FOO=bar\n");
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/lib/parser.test.ts`
Expected: FAIL — module not found

**Step 3: Implement parser**

Create `src/lib/parser.ts`:

```ts
export interface Variable {
  key: string;
  value: string;
}

export interface Profile {
  description: string;
  tags: string[];
  variables: Variable[];
}

export function parseProfile(content: string): Profile {
  const lines = content.split("\n");
  let description = "";
  let tags: string[] = [];
  const variables: Variable[] = [];

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith("# @description:")) {
      description = trimmed.slice("# @description:".length).trim();
    } else if (trimmed.startsWith("# @tags:")) {
      tags = trimmed
        .slice("# @tags:".length)
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean);
    } else if (trimmed.startsWith("#") || trimmed === "") {
      continue;
    } else {
      const eqIndex = trimmed.indexOf("=");
      if (eqIndex > 0) {
        variables.push({
          key: trimmed.slice(0, eqIndex),
          value: trimmed.slice(eqIndex + 1),
        });
      }
    }
  }

  return { description, tags, variables };
}

export function serializeProfile(profile: Profile): string {
  const lines: string[] = [];

  if (profile.description) {
    lines.push(`# @description: ${profile.description}`);
  }
  if (profile.tags.length > 0) {
    lines.push(`# @tags: ${profile.tags.join(", ")}`);
  }
  if (lines.length > 0) {
    lines.push("");
  }
  for (const v of profile.variables) {
    lines.push(`${v.key}=${v.value}`);
  }
  lines.push("");

  return lines.join("\n");
}
```

**Step 4: Run tests to verify they pass**

Run: `npx vitest run src/lib/parser.test.ts`
Expected: all tests PASS

**Step 5: Commit**

```bash
git add src/lib/parser.ts src/lib/parser.test.ts
git commit -m "feat: add profile parser/serializer with tests"
```

---

### Task 3: Envize hook (`src/hooks/useEnvize.ts`)

Wraps Tauri `Command.execute()` calls to the envize CLI.

**Key reference — real CLI JSON output shapes:**

`envize ls --json` returns:
```json
[
  {
    "name": "claude",
    "path": "/Users/.../.envize/profiles/claude.env",
    "isLocal": false,
    "description": "Claude API configuration",
    "tags": ["ai", "anthropic", "llm"],
    "variableCount": 2
  }
]
```

`envize status --json` returns:
```json
{
  "active_profiles": ["local-db"],
  "variables": {
    "DATABASE_URL": { "value": "post****", "source": "local-db" },
    "REDIS_URL": { "value": "redi****", "source": "local-db" }
  },
  "applied_at": "2026-02-11T06:56:06.192Z"
}
```

`envize templates --json` returns:
```json
[
  { "name": "claude", "description": "Anthropic Claude API configuration", "tags": ["ai"] }
]
```

**Files:**
- Create: `src/hooks/useEnvize.ts`
- Create: `src/types.ts` (shared TypeScript interfaces)

**Step 1: Create type definitions**

Create `src/types.ts`:

```ts
export interface ProfileSummary {
  name: string;
  path: string;
  isLocal: boolean;
  description: string;
  tags: string[];
  variableCount: number;
}

export interface StatusVariable {
  value: string;
  source: string;
}

export interface EnvizeStatus {
  active_profiles: string[];
  variables: Record<string, StatusVariable>;
  applied_at: string;
}

export interface TemplateSummary {
  name: string;
  description: string;
  tags: string[];
}
```

**Step 2: Create the hook**

Create `src/hooks/useEnvize.ts`:

```ts
import { useState, useCallback } from "react";
import { Command } from "@tauri-apps/plugin-shell";
import { readTextFile, writeTextFile } from "@tauri-apps/plugin-fs";
import { homeDir, join } from "@tauri-apps/api/path";
import type { ProfileSummary, EnvizeStatus, TemplateSummary } from "../types";

async function runEnvize(...args: string[]): Promise<string> {
  const cmd = Command.create("envize", args);
  const output = await cmd.execute();
  if (output.code !== 0) {
    throw new Error(output.stderr || `envize ${args.join(" ")} failed`);
  }
  return output.stdout;
}

export function useEnvize() {
  const [profiles, setProfiles] = useState<ProfileSummary[]>([]);
  const [status, setStatus] = useState<EnvizeStatus | null>(null);
  const [templates, setTemplates] = useState<TemplateSummary[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const refresh = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const [profilesJson, statusJson] = await Promise.all([
        runEnvize("ls", "--json"),
        runEnvize("status", "--json"),
      ]);
      setProfiles(JSON.parse(profilesJson));
      setStatus(JSON.parse(statusJson));
    } catch (e) {
      setError(e instanceof Error ? e.message : String(e));
    } finally {
      setLoading(false);
    }
  }, []);

  const fetchTemplates = useCallback(async () => {
    const json = await runEnvize("templates", "--json");
    const parsed = JSON.parse(json) as TemplateSummary[];
    setTemplates(parsed);
    return parsed;
  }, []);

  const activateProfiles = useCallback(
    async (profileNames: string[]) => {
      if (profileNames.length === 0) return;
      await runEnvize("use", ...profileNames, "--global");
      await refresh();
    },
    [refresh]
  );

  const createProfile = useCallback(
    async (name: string, template?: string) => {
      if (template) {
        await runEnvize("init", "--template", template, "--global");
      } else {
        await runEnvize("create", name, "--global");
      }
      await refresh();
    },
    [refresh]
  );

  const deleteProfile = useCallback(
    async (name: string) => {
      await runEnvize("rm", name);
      await refresh();
    },
    [refresh]
  );

  const readProfileContent = useCallback(async (profilePath: string) => {
    return await readTextFile(profilePath);
  }, []);

  const writeProfileContent = useCallback(
    async (profilePath: string, content: string) => {
      await writeTextFile(profilePath, content);
      await refresh();
    },
    [refresh]
  );

  return {
    profiles,
    status,
    templates,
    loading,
    error,
    refresh,
    fetchTemplates,
    activateProfiles,
    createProfile,
    deleteProfile,
    readProfileContent,
    writeProfileContent,
  };
}
```

**Step 3: Commit**

```bash
git add src/types.ts src/hooks/useEnvize.ts
git commit -m "feat: add useEnvize hook and type definitions"
```

---

### Task 4: Sidebar component (`src/components/Sidebar.tsx`)

**Files:**
- Create: `src/components/Sidebar.tsx`
- Create: `src/components/Sidebar.test.tsx`

**Step 1: Write failing tests**

Create `src/components/Sidebar.test.tsx`:

```tsx
import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { Sidebar } from "./Sidebar";
import type { ProfileSummary } from "../types";

const mockProfiles: ProfileSummary[] = [
  {
    name: "dev-api",
    path: "/home/user/.envize/profiles/dev-api.env",
    isLocal: false,
    description: "Dev API keys",
    tags: ["dev"],
    variableCount: 3,
  },
  {
    name: "staging",
    path: "/home/user/.envize/profiles/staging.env",
    isLocal: false,
    description: "Staging config",
    tags: ["staging"],
    variableCount: 2,
  },
];

describe("Sidebar", () => {
  it("renders profile names", () => {
    render(
      <Sidebar
        profiles={mockProfiles}
        activeProfiles={[]}
        selectedProfile={null}
        onSelectProfile={vi.fn()}
        onToggleProfile={vi.fn()}
        onAddProfile={vi.fn()}
        onDeleteProfile={vi.fn()}
      />
    );
    expect(screen.getByText("dev-api")).toBeInTheDocument();
    expect(screen.getByText("staging")).toBeInTheDocument();
  });

  it("highlights active profiles", () => {
    render(
      <Sidebar
        profiles={mockProfiles}
        activeProfiles={["dev-api"]}
        selectedProfile={null}
        onSelectProfile={vi.fn()}
        onToggleProfile={vi.fn()}
        onAddProfile={vi.fn()}
        onDeleteProfile={vi.fn()}
      />
    );
    const toggles = screen.getAllByRole("switch");
    expect(toggles[0]).toBeChecked();
    expect(toggles[1]).not.toBeChecked();
  });

  it("calls onSelectProfile when clicking a profile", async () => {
    const onSelect = vi.fn();
    render(
      <Sidebar
        profiles={mockProfiles}
        activeProfiles={[]}
        selectedProfile={null}
        onSelectProfile={onSelect}
        onToggleProfile={vi.fn()}
        onAddProfile={vi.fn()}
        onDeleteProfile={vi.fn()}
      />
    );
    await userEvent.click(screen.getByText("dev-api"));
    expect(onSelect).toHaveBeenCalledWith("dev-api");
  });

  it("renders + and - buttons", () => {
    render(
      <Sidebar
        profiles={mockProfiles}
        activeProfiles={[]}
        selectedProfile={null}
        onSelectProfile={vi.fn()}
        onToggleProfile={vi.fn()}
        onAddProfile={vi.fn()}
        onDeleteProfile={vi.fn()}
      />
    );
    expect(screen.getByLabelText("Add profile")).toBeInTheDocument();
    expect(screen.getByLabelText("Remove profile")).toBeInTheDocument();
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/components/Sidebar.test.tsx`
Expected: FAIL

**Step 3: Implement Sidebar**

Create `src/components/Sidebar.tsx`:

```tsx
import { useState } from "react";
import type { ProfileSummary, TemplateSummary } from "../types";

interface SidebarProps {
  profiles: ProfileSummary[];
  activeProfiles: string[];
  selectedProfile: string | null;
  onSelectProfile: (name: string) => void;
  onToggleProfile: (name: string, active: boolean) => void;
  onAddProfile: (name: string, template?: string) => void;
  onDeleteProfile: (name: string) => void;
  templates?: TemplateSummary[];
  onFetchTemplates?: () => Promise<TemplateSummary[]>;
}

export function Sidebar({
  profiles,
  activeProfiles,
  selectedProfile,
  onSelectProfile,
  onToggleProfile,
  onAddProfile,
  onDeleteProfile,
  templates = [],
  onFetchTemplates,
}: SidebarProps) {
  const [showAddMenu, setShowAddMenu] = useState(false);
  const [newName, setNewName] = useState("");
  const [showConfirmDelete, setShowConfirmDelete] = useState(false);

  const handleAdd = async (template?: string) => {
    if (template) {
      onAddProfile(template, template);
    } else if (newName.trim()) {
      onAddProfile(newName.trim());
      setNewName("");
    }
    setShowAddMenu(false);
  };

  const handleDelete = () => {
    if (selectedProfile) {
      onDeleteProfile(selectedProfile);
      setShowConfirmDelete(false);
    }
  };

  return (
    <div className="w-64 border-r border-gray-200 flex flex-col h-full bg-gray-50">
      <div className="p-3 text-sm font-semibold text-gray-500 uppercase tracking-wide">
        Profiles
      </div>
      <div className="flex-1 overflow-y-auto">
        {profiles.map((p) => {
          const isActive = activeProfiles.includes(p.name);
          const isSelected = selectedProfile === p.name;
          return (
            <div
              key={p.name}
              className={`flex items-center justify-between px-3 py-2 cursor-pointer ${
                isSelected ? "bg-blue-100" : "hover:bg-gray-100"
              }`}
              onClick={() => onSelectProfile(p.name)}
            >
              <span className="text-sm truncate">{p.name}</span>
              <button
                role="switch"
                aria-checked={isActive}
                onClick={(e) => {
                  e.stopPropagation();
                  onToggleProfile(p.name, !isActive);
                }}
                className={`w-8 h-4 rounded-full relative transition-colors ${
                  isActive ? "bg-green-500" : "bg-gray-300"
                }`}
              >
                <span
                  className={`absolute top-0.5 w-3 h-3 rounded-full bg-white transition-transform ${
                    isActive ? "translate-x-4" : "translate-x-0.5"
                  }`}
                />
              </button>
            </div>
          );
        })}
      </div>

      {/* Add menu popover */}
      {showAddMenu && (
        <div className="border-t border-gray-200 p-3 bg-white">
          <div className="mb-2">
            <input
              type="text"
              placeholder="New profile name"
              value={newName}
              onChange={(e) => setNewName(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleAdd()}
              className="w-full text-sm border border-gray-300 rounded px-2 py-1"
            />
            <button
              onClick={() => handleAdd()}
              disabled={!newName.trim()}
              className="mt-1 w-full text-sm bg-blue-500 text-white rounded px-2 py-1 disabled:opacity-50"
            >
              Create Empty
            </button>
          </div>
          {templates.length > 0 && (
            <div>
              <div className="text-xs text-gray-500 mb-1">From template:</div>
              {templates.map((t) => (
                <button
                  key={t.name}
                  onClick={() => handleAdd(t.name)}
                  className="block w-full text-left text-sm px-2 py-1 hover:bg-gray-100 rounded"
                >
                  {t.name}
                </button>
              ))}
            </div>
          )}
        </div>
      )}

      {/* Confirm delete dialog */}
      {showConfirmDelete && selectedProfile && (
        <div className="border-t border-gray-200 p-3 bg-white">
          <p className="text-sm mb-2">
            Delete <strong>{selectedProfile}</strong>?
          </p>
          <div className="flex gap-2">
            <button
              onClick={handleDelete}
              className="flex-1 text-sm bg-red-500 text-white rounded px-2 py-1"
            >
              Delete
            </button>
            <button
              onClick={() => setShowConfirmDelete(false)}
              className="flex-1 text-sm border border-gray-300 rounded px-2 py-1"
            >
              Cancel
            </button>
          </div>
        </div>
      )}

      {/* Bottom + / - buttons */}
      <div className="border-t border-gray-200 flex">
        <button
          aria-label="Add profile"
          onClick={async () => {
            if (onFetchTemplates) await onFetchTemplates();
            setShowAddMenu(!showAddMenu);
            setShowConfirmDelete(false);
          }}
          className="flex-1 py-2 text-center text-lg hover:bg-gray-100"
        >
          +
        </button>
        <button
          aria-label="Remove profile"
          onClick={() => {
            setShowConfirmDelete(!showConfirmDelete);
            setShowAddMenu(false);
          }}
          disabled={!selectedProfile}
          className="flex-1 py-2 text-center text-lg hover:bg-gray-100 disabled:opacity-30"
        >
          −
        </button>
      </div>
    </div>
  );
}
```

**Step 4: Run tests**

Run: `npx vitest run src/components/Sidebar.test.tsx`
Expected: PASS

**Step 5: Commit**

```bash
git add src/components/Sidebar.tsx src/components/Sidebar.test.tsx
git commit -m "feat: add Sidebar component with tests"
```

---

### Task 5: ProfileEditor component (`src/components/ProfileEditor.tsx`)

**Files:**
- Create: `src/components/ProfileEditor.tsx`
- Create: `src/components/ProfileEditor.test.tsx`

**Step 1: Write failing tests**

Create `src/components/ProfileEditor.test.tsx`:

```tsx
import { describe, it, expect, vi } from "vitest";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ProfileEditor } from "./ProfileEditor";
import type { Profile } from "../lib/parser";

const mockProfile: Profile = {
  description: "Dev API keys",
  tags: ["dev", "api"],
  variables: [
    { key: "API_KEY", value: "sk-abc123" },
    { key: "API_URL", value: "https://api.example.com" },
  ],
};

describe("ProfileEditor", () => {
  it("renders profile metadata", () => {
    render(
      <ProfileEditor
        name="dev-api"
        profile={mockProfile}
        onSave={vi.fn()}
      />
    );
    expect(screen.getByDisplayValue("Dev API keys")).toBeInTheDocument();
    expect(screen.getByDisplayValue("dev, api")).toBeInTheDocument();
  });

  it("renders variable rows", () => {
    render(
      <ProfileEditor
        name="dev-api"
        profile={mockProfile}
        onSave={vi.fn()}
      />
    );
    expect(screen.getByDisplayValue("API_KEY")).toBeInTheDocument();
    expect(screen.getByDisplayValue("sk-abc123")).toBeInTheDocument();
    expect(screen.getByDisplayValue("API_URL")).toBeInTheDocument();
  });

  it("shows empty state when no profile selected", () => {
    render(
      <ProfileEditor name={null} profile={null} onSave={vi.fn()} />
    );
    expect(screen.getByText(/select a profile/i)).toBeInTheDocument();
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/components/ProfileEditor.test.tsx`
Expected: FAIL

**Step 3: Implement ProfileEditor**

Create `src/components/ProfileEditor.tsx`:

```tsx
import { useState, useEffect } from "react";
import type { Profile, Variable } from "../lib/parser";

interface ProfileEditorProps {
  name: string | null;
  profile: Profile | null;
  onSave: (profile: Profile) => void;
}

export function ProfileEditor({ name, profile, onSave }: ProfileEditorProps) {
  const [description, setDescription] = useState("");
  const [tagsStr, setTagsStr] = useState("");
  const [variables, setVariables] = useState<Variable[]>([]);
  const [dirty, setDirty] = useState(false);

  useEffect(() => {
    if (profile) {
      setDescription(profile.description);
      setTagsStr(profile.tags.join(", "));
      setVariables([...profile.variables]);
      setDirty(false);
    }
  }, [profile, name]);

  if (!name || !profile) {
    return (
      <div className="flex-1 flex items-center justify-center text-gray-400">
        Select a profile to edit
      </div>
    );
  }

  const updateVariable = (index: number, field: "key" | "value", val: string) => {
    const updated = [...variables];
    updated[index] = { ...updated[index], [field]: val };
    setVariables(updated);
    setDirty(true);
  };

  const addVariable = () => {
    setVariables([...variables, { key: "", value: "" }]);
    setDirty(true);
  };

  const removeVariable = (index: number) => {
    setVariables(variables.filter((_, i) => i !== index));
    setDirty(true);
  };

  const handleSave = () => {
    onSave({
      description,
      tags: tagsStr
        .split(",")
        .map((t) => t.trim())
        .filter(Boolean),
      variables: variables.filter((v) => v.key.trim()),
    });
    setDirty(false);
  };

  return (
    <div className="flex-1 flex flex-col p-4 overflow-y-auto">
      <div className="mb-4">
        <h2 className="text-lg font-semibold mb-3">{name}</h2>
        <div className="space-y-2">
          <input
            type="text"
            placeholder="Description"
            value={description}
            onChange={(e) => { setDescription(e.target.value); setDirty(true); }}
            className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
          />
          <input
            type="text"
            placeholder="Tags (comma-separated)"
            value={tagsStr}
            onChange={(e) => { setTagsStr(e.target.value); setDirty(true); }}
            className="w-full border border-gray-300 rounded px-2 py-1 text-sm"
          />
        </div>
      </div>

      <div className="flex-1">
        <div className="flex items-center justify-between mb-2">
          <span className="text-sm font-medium text-gray-500">Variables</span>
          <button
            onClick={addVariable}
            className="text-sm text-blue-500 hover:text-blue-700"
          >
            + Add
          </button>
        </div>
        <div className="space-y-1">
          {variables.map((v, i) => (
            <div key={i} className="flex gap-2 items-center">
              <input
                type="text"
                placeholder="KEY"
                value={v.key}
                onChange={(e) => updateVariable(i, "key", e.target.value)}
                className="w-1/3 border border-gray-300 rounded px-2 py-1 text-sm font-mono"
              />
              <span className="text-gray-400">=</span>
              <input
                type="text"
                placeholder="value"
                value={v.value}
                onChange={(e) => updateVariable(i, "value", e.target.value)}
                className="flex-1 border border-gray-300 rounded px-2 py-1 text-sm font-mono"
              />
              <button
                onClick={() => removeVariable(i)}
                className="text-red-400 hover:text-red-600 text-sm"
              >
                ×
              </button>
            </div>
          ))}
        </div>
      </div>

      {dirty && (
        <div className="mt-4 pt-3 border-t border-gray-200">
          <button
            onClick={handleSave}
            className="bg-blue-500 text-white rounded px-4 py-1.5 text-sm hover:bg-blue-600"
          >
            Save
          </button>
        </div>
      )}
    </div>
  );
}
```

**Step 4: Run tests**

Run: `npx vitest run src/components/ProfileEditor.test.tsx`
Expected: PASS

**Step 5: Commit**

```bash
git add src/components/ProfileEditor.tsx src/components/ProfileEditor.test.tsx
git commit -m "feat: add ProfileEditor component with tests"
```

---

### Task 6: StatusBar component (`src/components/StatusBar.tsx`)

**Files:**
- Create: `src/components/StatusBar.tsx`
- Create: `src/components/StatusBar.test.tsx`

**Step 1: Write failing tests**

Create `src/components/StatusBar.test.tsx`:

```tsx
import { describe, it, expect } from "vitest";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { StatusBar } from "./StatusBar";
import type { EnvizeStatus } from "../types";

const mockStatus: EnvizeStatus = {
  active_profiles: ["dev-api", "local-db"],
  variables: {
    API_KEY: { value: "sk-a****", source: "dev-api" },
    DATABASE_URL: { value: "post****", source: "local-db" },
  },
  applied_at: "2026-02-11T06:56:06.192Z",
};

describe("StatusBar", () => {
  it("shows active profile count when collapsed", () => {
    render(<StatusBar status={mockStatus} />);
    expect(screen.getByText(/2 active/i)).toBeInTheDocument();
  });

  it("expands to show variables on click", async () => {
    render(<StatusBar status={mockStatus} />);
    await userEvent.click(screen.getByText(/2 active/i));
    expect(screen.getByText("API_KEY")).toBeInTheDocument();
    expect(screen.getByText("DATABASE_URL")).toBeInTheDocument();
  });

  it("shows nothing active when no status", () => {
    render(<StatusBar status={null} />);
    expect(screen.getByText(/no active/i)).toBeInTheDocument();
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/components/StatusBar.test.tsx`
Expected: FAIL

**Step 3: Implement StatusBar**

Create `src/components/StatusBar.tsx`:

```tsx
import { useState } from "react";
import type { EnvizeStatus } from "../types";

interface StatusBarProps {
  status: EnvizeStatus | null;
}

export function StatusBar({ status }: StatusBarProps) {
  const [expanded, setExpanded] = useState(false);

  const activeCount = status?.active_profiles.length ?? 0;
  const variables = status ? Object.entries(status.variables) : [];

  return (
    <div className="border-t border-gray-200 bg-gray-50">
      <button
        onClick={() => setExpanded(!expanded)}
        className="w-full px-4 py-2 flex items-center justify-between text-sm hover:bg-gray-100"
      >
        <span>
          {activeCount > 0
            ? `${activeCount} active profile${activeCount > 1 ? "s" : ""}`
            : "No active profiles"}
        </span>
        <span className="text-gray-400">{expanded ? "▼" : "▶"}</span>
      </button>
      {expanded && variables.length > 0 && (
        <div className="px-4 pb-3 max-h-48 overflow-y-auto">
          <table className="w-full text-sm font-mono">
            <tbody>
              {variables.map(([key, { value, source }]) => (
                <tr key={key} className="border-t border-gray-100">
                  <td className="py-1 pr-3 font-medium">{key}</td>
                  <td className="py-1 pr-3 text-gray-600">{value}</td>
                  <td className="py-1 text-gray-400 text-xs">{source}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}
```

**Step 4: Run tests**

Run: `npx vitest run src/components/StatusBar.test.tsx`
Expected: PASS

**Step 5: Commit**

```bash
git add src/components/StatusBar.tsx src/components/StatusBar.test.tsx
git commit -m "feat: add StatusBar component with tests"
```

---

### Task 7: Wire up App.tsx

Connects all components and the useEnvize hook into the single-screen layout.

**Files:**
- Modify: `src/App.tsx`

**Step 1: Implement App**

Replace `src/App.tsx`:

```tsx
import { useEffect, useState } from "react";
import { useEnvize } from "./hooks/useEnvize";
import { parseProfile, serializeProfile } from "./lib/parser";
import { Sidebar } from "./components/Sidebar";
import { ProfileEditor } from "./components/ProfileEditor";
import { StatusBar } from "./components/StatusBar";
import type { Profile } from "./lib/parser";

function App() {
  const envize = useEnvize();
  const [selectedName, setSelectedName] = useState<string | null>(null);
  const [editingProfile, setEditingProfile] = useState<Profile | null>(null);

  useEffect(() => {
    envize.refresh();
  }, []);

  // Refresh on window focus
  useEffect(() => {
    const onFocus = () => envize.refresh();
    window.addEventListener("focus", onFocus);
    return () => window.removeEventListener("focus", onFocus);
  }, [envize.refresh]);

  const handleSelectProfile = async (name: string) => {
    setSelectedName(name);
    const profile = envize.profiles.find((p) => p.name === name);
    if (profile) {
      const content = await envize.readProfileContent(profile.path);
      setEditingProfile(parseProfile(content));
    }
  };

  const handleToggleProfile = async (name: string, active: boolean) => {
    const currentActive = envize.status?.active_profiles ?? [];
    const newActive = active
      ? [...currentActive, name]
      : currentActive.filter((n) => n !== name);
    await envize.activateProfiles(newActive);
  };

  const handleSave = async (profile: Profile) => {
    const p = envize.profiles.find((p) => p.name === selectedName);
    if (p) {
      await envize.writeProfileContent(p.path, serializeProfile(profile));
      setEditingProfile(profile);
    }
  };

  const handleAddProfile = async (name: string, template?: string) => {
    await envize.createProfile(name, template);
    setSelectedName(name);
  };

  const handleDeleteProfile = async (name: string) => {
    await envize.deleteProfile(name);
    if (selectedName === name) {
      setSelectedName(null);
      setEditingProfile(null);
    }
  };

  return (
    <div className="h-screen flex flex-col">
      {envize.error && (
        <div className="bg-red-50 text-red-700 px-4 py-2 text-sm">
          {envize.error}
        </div>
      )}
      <div className="flex flex-1 overflow-hidden">
        <Sidebar
          profiles={envize.profiles}
          activeProfiles={envize.status?.active_profiles ?? []}
          selectedProfile={selectedName}
          onSelectProfile={handleSelectProfile}
          onToggleProfile={handleToggleProfile}
          onAddProfile={handleAddProfile}
          onDeleteProfile={handleDeleteProfile}
          templates={envize.templates}
          onFetchTemplates={envize.fetchTemplates}
        />
        <ProfileEditor
          name={selectedName}
          profile={editingProfile}
          onSave={handleSave}
        />
      </div>
      <StatusBar status={envize.status} />
    </div>
  );
}

export default App;
```

**Step 2: Verify all tests pass**

Run: `npx vitest run`
Expected: all tests PASS

**Step 3: Verify app builds**

Run: `npm run build`
Expected: successful build

**Step 4: Commit**

```bash
git add src/App.tsx
git commit -m "feat: wire up App with all components"
```

---

### Task 8: Tauri shell command configuration

Configure Tauri to allow executing `envize` and reading/writing profile files.

**Files:**
- Modify: `src-tauri/capabilities/default.json`

**Step 1: Update Tauri shell permissions**

The Tauri shell plugin requires explicit configuration of allowed commands. Update `src-tauri/capabilities/default.json` to include a scoped shell command for envize:

In `src-tauri/tauri.conf.json`, add the plugin config (or in a separate plugin config file depending on scaffold output):

```json
{
  "plugins": {
    "shell": {
      "open": true,
      "scope": [
        {
          "name": "envize",
          "cmd": "envize",
          "args": true
        }
      ]
    }
  }
}
```

Also ensure the fs plugin scope allows reading/writing to `~/.envize/profiles/`:

```json
{
  "plugins": {
    "fs": {
      "scope": ["$HOME/.envize/**"]
    }
  }
}
```

**Step 2: Install frontend Tauri plugin packages**

Run:
```bash
npm install @tauri-apps/plugin-shell @tauri-apps/plugin-fs
```

**Step 3: Verify Tauri dev mode works**

Run: `npm run tauri dev`
Expected: App window opens, sidebar loads profiles from `envize ls --json`

**Step 4: Commit**

```bash
git add -A
git commit -m "feat: configure Tauri shell and fs permissions"
```

---

### Task 9: End-to-end smoke test

**Step 1: Manual verification**

Run `npm run tauri dev` and verify:
- [ ] Profiles appear in sidebar
- [ ] Toggle activates/deactivates profiles
- [ ] Clicking a profile shows its variables in the editor
- [ ] Editing and saving updates the file
- [ ] + button shows create popover with templates
- [ ] - button deletes with confirmation
- [ ] Status bar shows active environment
- [ ] Refreshes on window focus

**Step 2: Fix any issues found**

**Step 3: Final commit**

```bash
git add -A
git commit -m "fix: polish UI and resolve integration issues"
```
